// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: skroman_user.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countOFClients = `-- name: CountOFClients :one
select count(*) from skroman_client
`

func (q *Queries) CountOFClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOFClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSkromanUser = `-- name: CreateSkromanUser :one
insert into skroman_client (
    user_name,
    email,
    password,
    contact,
    address,
    city,
    state,
    pincode
) values (
    $1,$2,$3,$4,$5,$6,$7,$8
) returning id, user_name, email, password, contact, address, city, state, pincode, created_at, updated_at
`

type CreateSkromanUserParams struct {
	UserName string         `json:"user_name"`
	Email    string         `json:"email"`
	Password sql.NullString `json:"password"`
	Contact  string         `json:"contact"`
	Address  string         `json:"address"`
	City     sql.NullString `json:"city"`
	State    sql.NullString `json:"state"`
	Pincode  sql.NullString `json:"pincode"`
}

// create/register new user
func (q *Queries) CreateSkromanUser(ctx context.Context, arg CreateSkromanUserParams) (SkromanClient, error) {
	row := q.db.QueryRowContext(ctx, createSkromanUser,
		arg.UserName,
		arg.Email,
		arg.Password,
		arg.Contact,
		arg.Address,
		arg.City,
		arg.State,
		arg.Pincode,
	)
	var i SkromanClient
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Password,
		&i.Contact,
		&i.Address,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteClient = `-- name: DeleteClient :execresult
delete from skroman_client
where id = $1
`

func (q *Queries) DeleteClient(ctx context.Context, id uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteClient, id)
}

const fetchAllClients = `-- name: FetchAllClients :many
select id, user_name, email, password, contact, address, city, state, pincode, created_at, updated_at from skroman_client
order by created_at desc    
limit $1
offset $2
`

type FetchAllClientsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) FetchAllClients(ctx context.Context, arg FetchAllClientsParams) ([]SkromanClient, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllClients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SkromanClient{}
	for rows.Next() {
		var i SkromanClient
		if err := rows.Scan(
			&i.ID,
			&i.UserName,
			&i.Email,
			&i.Password,
			&i.Contact,
			&i.Address,
			&i.City,
			&i.State,
			&i.Pincode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchClientById = `-- name: FetchClientById :one
select id, user_name, email, password, contact, address, city, state, pincode, created_at, updated_at from skroman_client
where id = $1
limit 1
`

func (q *Queries) FetchClientById(ctx context.Context, id uuid.UUID) (SkromanClient, error) {
	row := q.db.QueryRowContext(ctx, fetchClientById, id)
	var i SkromanClient
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Password,
		&i.Contact,
		&i.Address,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSkromanClientInfo = `-- name: UpdateSkromanClientInfo :one
update skroman_client
set user_name=$2,
email=$3,password=$4,contact=$5,
address=$6,city=$7,state=$8,pincode=$9,
updated_at = CURRENT_TIMESTAMP
where id=$1
returning id, user_name, email, password, contact, address, city, state, pincode, created_at, updated_at
`

type UpdateSkromanClientInfoParams struct {
	ID       uuid.UUID      `json:"id"`
	UserName string         `json:"user_name"`
	Email    string         `json:"email"`
	Password sql.NullString `json:"password"`
	Contact  string         `json:"contact"`
	Address  string         `json:"address"`
	City     sql.NullString `json:"city"`
	State    sql.NullString `json:"state"`
	Pincode  sql.NullString `json:"pincode"`
}

// update skroman client info
func (q *Queries) UpdateSkromanClientInfo(ctx context.Context, arg UpdateSkromanClientInfoParams) (SkromanClient, error) {
	row := q.db.QueryRowContext(ctx, updateSkromanClientInfo,
		arg.ID,
		arg.UserName,
		arg.Email,
		arg.Password,
		arg.Contact,
		arg.Address,
		arg.City,
		arg.State,
		arg.Pincode,
	)
	var i SkromanClient
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Email,
		&i.Password,
		&i.Contact,
		&i.Address,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
